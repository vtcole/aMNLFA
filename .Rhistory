points(output$N, output$zpb7, col = "#009900", pch = 19)
lines(output$N, output$zpb6, col = "#0000CC", lwd = 1.5)
points(output$N, output$zpb6, col = "#0000CC", pch = 19)
lines(output$N, output$zpb8, col = "#990099", lwd = 1.5)
points(output$N, output$zpb8, col = "#990099", pch = 19)
legend("bottomright", bty = "n", legend = c("Path A", "Path B", "Path C", "Path D"), fill = c("#CC0000", "#009900", "#0000CC", "#990099"))
```
```{r, echo = FALSE}
plot(-100, xlim = c(min(output$N), max(output$N)), ylim = c(0, 1), xlab = "Sample Size", ylab = "Power")
abline(h = .8)
lines(output$N, output$zpb1, col = "#CC0000", lwd = 1.5)
points(output$N, output$zpb1, col = "#CC0000", pch = 19)
lines(output$N, output$zpb7, col = "#009900", lwd = 1.5)
points(output$N, output$zpb7, col = "#009900", pch = 19)
lines(output$N, output$zpb6, col = "#0000CC", lwd = 1.5)
points(output$N, output$zpb6, col = "#0000CC", pch = 19)
lines(output$N, output$zpb8, col = "#990099", lwd = 1.5)
points(output$N, output$zpb8, col = "#990099", pch = 19)
legend("bottomright", bty = "n", legend = c("Path A", "Path B", "Path C", "Path D"), fill = c("#CC0000", "#009900", "#0000CC", "#990099"))
```
Given that power was relatively strong at our projected sample size for small effects, we confirmed that there was also adequate power to detect medium and large effects. Medium and large effects were simulated to be 2 and 3 times the size of the small effects, respectively. As shown, power is above .8 in all cases, even at much lower sample sizes than the projected value of $N = 312$.
## Medium effect size
```{r, cache = TRUE, echo = FALSE, warnings = FALSE, include = FALSE}
###   A programme to obtain the power of parameters in 2 level
#       unbalanced model  with  Normal response
#                    generated on 08/03/21
###~~~~~~~~~~~~~~~~~     Required packages  ~~~~~~~~~~~~~~~~~~~~~###
library(MASS)
library(lme4)
###~~~~~~~~~~~~~~~~~~~     Initial inputs    ~~~~~~~~~~~~~~~~~~~~###
set.seed(585858)
siglevel<-0.00899434965
z1score<-abs(qnorm(siglevel))
simus<-500
n1low<-4
n1high<-4
n1step<-1
unbalprob<-0.10
n2low<-204
n2high<-396
n2step<-12
npred<-8
randsize<-2
beta<-c(0.000,
0.300, #Tx effect - b1
0.300, #Time effect - b2
0.300, #Race effect 1 - b3
0.300, #Race effect 2 - b4
-0.600, #Discrimination - b5
0.600, #Interaction between discrimination and Tx - b6
0.900, #Interaction between time and Tx - b7
0.600 #Interaction between time, Tx, and discrimination - b8
)
betasize<-length(beta)
effectbeta<-abs(beta)
sgnbeta<-sign(beta)
xtype<-c(1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000)
randcolumn<-c(3.000000)
sigma2u<-matrix(c(1.000,0,0,1.000),randsize,randsize)
sigmae<-sqrt(1.000)
n1range<-seq(n1low,n1high,n1step)
n2range<-seq(n2low,n2high,n2step)
n1size<-length(n1range)
n2size<-length(n2range)
totalsize<-n1size*n2size
finaloutput<-matrix(0,totalsize,6*betasize)
rowcount<-1
##-------------------        Inputs for model fitting       ---------------##
fixname<-c("x0","x1","x2","x3","x4","x5","x6","x7","x8")
fixform<-"1+x1+x2+x3+x4+x5+x6+x7+x8"
randform<-"(x2|l2id)"
expression<-paste(c(fixform,randform),collapse="+")
modelformula<-formula(paste("y ~",expression))
data<-vector("list",2+length(fixname))
names(data)<-c("l2id","y",fixname)
#####--------- Initial input for power in two approaches ----------------#####
powaprox<-vector("list",betasize)
names(powaprox)<-c("b0","b1","b2","b3","b4","b5","b6","b7","b8")
powsde<-powaprox
cat("        The programme was executed at", date(),"\n")
cat("--------------------------------------------------------------------\n")
###-----------------------  Sample size combination  -----------------------###
for(n2 in seq(n2low,n2high,n2step)){
n2run<-n2
for(n1 in seq(n1low,n1high,n1step)){
#cat(" Start  of simulation for ",n2run," macro and unbalanced micro with base ",n1," units \n") #No need for this in RMarkdown
sdepower<-matrix(0,betasize,simus)
powaprox[1:betasize]<-rep(0,betasize)
powsde<-powaprox
###-----------------------   Simulation step  -----------------------###
for(iter in 1:simus){
if (iter/10==floor(iter/10)){
cat(" Iteration remain=",simus-iter,"\n")
}
n1unbal<-rbinom(n2run,n1,1-unbalprob)
n1unbal<-n1unbal[n1unbal>0]
n2<-length(n1unbal)
cumn1<-c(0,cumsum(n1unbal))
length=sum(n1unbal)
y<-rep(0,length)
x<-matrix(1,length,betasize)
z<-matrix(1,length,randsize)
l2id<-rep(c(1:n2),n1unbal)
## +++++++++++++++++++       Set up X matrix       +++++++++++++++++++  ##
#############This part was changed for the current research.###################
group <- rbinom(n2, 1, .5)
aa.last <- floor(n2/3)
as.last <- floor(n2*(2/3))
aa <- rep(0, n2)
aa[1:aa.last] <- 1
as <- rep(0, n2)
as[(aa.last+1):as.last] <- 1
disc <- rnorm(n2) + .1*as - .1*aa
disc <- disc/sd(disc)
x[,1] <- 1
for (x.iter in 1:nrow(x)) {
x[x.iter, 2] <- group[l2id[x.iter]]
x[x.iter, 4] <- aa[l2id[x.iter]]
x[x.iter, 5] <- as[l2id[x.iter]]
x[x.iter, 6] <- disc[l2id[x.iter]]
}
for (l2.iter in unique(l2id)) {
l2.indices <- which(l2id == l2.iter)
x[l2.indices, 3] <- 0:(length(l2.indices) - 1)
}
x[,3] <- x[,3]*3 - 6
#Interaction between discrimination and Tx
x[,7] <- x[,6]*x[,2]
#Interaction between time and Tx
x[,8] <- x[,3]*x[,2]
#Interaction between discrimination, time, and Tx
x[,9] <- x[,3]*x[,2]*x[,6]
x[,2] <- x[,2]/sd(x[,2])
x[,3] <- x[,3]/sd(x[,3])
x[,4] <- x[,4]/sd(x[,4])
x[,5] <- x[,5]/sd(x[,5])
x[,6] <- x[,6]/sd(x[,6])
x[,7] <- x[,7]/sd(x[,7])
x[,8] <- x[,8]/sd(x[,8])
x[,9] <- x[,9]/sd(x[,9])
#######------------       To set up Z matrix          --------------########
for(j in 2:dim(z)[2]) z[,j]<-x[,randcolumn[j-1]]
##--------------------------------------------------------------##
e<-rnorm(length,0,sigmae)
u<-mvrnorm(n2,rep(0,randsize),sigma2u)
fixpart<-x%*%beta
randpart<-rowSums(z*u[l2id,])
y<-fixpart+randpart+e
##-------------------        Inputs for model fitting       ---------------##
data$l2id<-as.factor(l2id)
data$y<-y
data$x0<-x[,1]
data$x1<-x[,2]
data$x2<-x[,3]
data$x3<-x[,4]
data$x4<-x[,5]
data$x5<-x[,6]
data$x6<-x[,7]
data$x7<-x[,8]
data$x8<-x[,9]
###~~~~~~~~~~      Fitting the model using lmer funtion    ~~~~~~~~~~###
(fitmodel <- lmer(modelformula,data))
######~~~~~~~~~~   To obtain the power of parameter(s) ~~~~~~~~~~######
estbeta<-fixef(fitmodel)
sdebeta<-sqrt(diag(vcov(fitmodel)))
for(l in 1:betasize)
{
cibeta<-estbeta[l]-sgnbeta[l]*z1score*sdebeta[l]
if(beta[l]*cibeta>0)              powaprox[[l]]<-powaprox[[l]]+1
sdepower[l,iter]<-as.numeric(sdebeta[l])
}
##-------------------------------------------------------------------------##
} ##  iteration end here
###---------                  Powers and their CIs             ---------###
for(l in 1:betasize){
meanaprox<-powaprox[[l]]<-unlist(powaprox[[l]]/simus)
Laprox<-meanaprox-z1score*sqrt(meanaprox*(1-meanaprox)/simus)
Uaprox<-meanaprox+z1score*sqrt(meanaprox*(1-meanaprox)/simus)
meansde<-mean(sdepower[l,])
varsde<-var(sdepower[l,])
USDE<-meansde-z1score*sqrt(varsde/simus)
LSDE<-meansde+z1score*sqrt(varsde/simus)
powLSDE<- pnorm(effectbeta[l]/LSDE-z1score)
powUSDE<- pnorm(effectbeta[l]/USDE-z1score)
powsde[[l]]<-pnorm(effectbeta[l]/meansde-z1score)
###		Restrict the CIs within 0 and 1		###
if(Laprox<0) Laprox<-0
if(Uaprox>1) Uaprox<-1
if(powLSDE<0) powLSDE<-0
if(powUSDE >1) powUSDE<-1
finaloutput[rowcount,(6*l-5):(6*l-3)]<-c(Laprox,meanaprox,Uaprox)
finaloutput[rowcount,(6*l-2):(6*l)]<-c(powLSDE,powsde[[l]],powUSDE)
}
###~~~~~~~~~~      Set out the results in a data frame    ~~~~~~~~~~###
result<-matrix(c(powaprox,powsde),byrow=T,nrow=2)
result<-as.data.frame(result)
row.names(result)<-c("Approx Approach","SDE Approach")
names(result)<-names(powaprox)
cat("                    power of parameter(s) for the sample size  of ",n1,"first and",n2,"second levels \n")
print(result)
rowcount<-rowcount+1
cat("--------------------------------------------------------------------\n")
} ## end of the loop  over the first level
} ## end of the loop  over the second level
###---------         Export output in a file                      ---------###
finaloutput<-as.data.frame(round(finaloutput,3))
output<-data.frame(cbind(rep(n2range,each=n1size),rep(n1range,n2size),finaloutput))
names(output)<-c("N","n","zLb0","zpb0","zUb0","sLb0","spb0","sUb0","zLb1","zpb1","zUb1","sLb1","spb1","sUb1","zLb2","zpb2","zUb2","sLb2","spb2","sUb2","zLb3","zpb3","zUb3","sLb3","spb3","sUb3","zLb4","zpb4","zUb4","sLb4","spb4","sUb4","zLb5","zpb5","zUb5","sLb5","spb5","sUb5","zLb6","zpb6","zUb6","sLb6","spb6","sUb6","zLb7","zpb7","zUb7","sLb7","spb7","sUb7","zLb8","zpb8","zUb8","sLb8","spb8","sUb8")
#write.table(output,"powerout.txt",sep="\t ",quote=F,eol="\n",dec=".",col.names=T,row.names=F,qmethod="double")
plot(-100, xlim = c(min(output$N), max(output$N)), ylim = c(0, 1), xlab = "Sample Size", ylab = "Power")
abline(h = .8)
lines(output$N, output$zpb1, col = "#CC0000", lwd = 1.5)
points(output$N, output$zpb1, col = "#CC0000", pch = 19)
lines(output$N, output$zpb7, col = "#009900", lwd = 1.5)
points(output$N, output$zpb7, col = "#009900", pch = 19)
lines(output$N, output$zpb6, col = "#0000CC", lwd = 1.5)
points(output$N, output$zpb6, col = "#0000CC", pch = 19)
lines(output$N, output$zpb8, col = "#990099", lwd = 1.5)
points(output$N, output$zpb8, col = "#990099", pch = 19)
legend("bottomright", bty = "n", legend = c("Path A", "Path B", "Path C", "Path D"), fill = c("#CC0000", "#009900", "#0000CC", "#990099"))
install.packages("WebPower")
library(WebPower)
wp.rmanova(n=104, ng=2, nm=2, f=0.1, nscor=0.7)
wp.rmanova(n=104, ng=2, nm=2, f=0.1, nscor=0.7, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=0.35, nscor=0.7, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=0.1, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=0.2, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=4, f=0.1, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=0.1, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=0.1, nscor=0, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=0.1, nscor=.01, type = 2)
sqrt(.5)
ctrl.1 <- rnorm(104)
ctrl.2 <- .707*rnorm(104) + .707*ctrl.1
var(ctrl.1)
var(ctrl.2)
ctrl.1 <- rnorm(10400000)
ctrl.2 <- .707*rnorm(10400000) + .707*ctrl.1
var(ctrl.2)
var(ctrl.1)
ctrl.1 <- rnorm(104)
ctrl.2 <- .707*rnorm(104) + .707*ctrl.1
tx.1 <- rnorm(104)
tx.2 <- .707*rnorm(104) + .707*tx.1 + .05
wp.rmanova(n=104, ng=2, nm=2, f=NULL, power = .8, nscor=0, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=NULL, power = .8, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=4, f=NULL, power = .8, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=NULL, power = .8, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=NULL, power = .8, nscor=1, type = 2)
wp.rmanova(n=104, ng=2, nm=2, f=NULL, power = .75, nscor=1, type = 2)
devtools::install_github("arcaldwell49/Superpower")
ctrl.1 <- rnorm(10000)
ctrl.2 <- .707*rnorm(10000) + .707*ctrl.1
tx.1 <- rnorm(10000)
tx.2 <- .707*rnorm(10000) + .707*tx.1 + .05
all.for.cor <- cbind(ctrl.1, tx.1, ctrol.2, tx.2)
all.for.cor <- cbind(ctrl.1, tx.1, ctrl.2, tx.2)
cor(all.for.cor)
library(superpower)
library(Superpower)
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, 1),
sd = 2,
r <- c(0, .7, 0),
plot = FALSE)
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, 1),
sd = 2,
r <- c(0, .7, 0, 0, .7, 0),
plot = FALSE)
design_result
design_result <- ANOVA_design(design = "2w*2b",
n = 104,
mu = c(0, 0, 0, 1),
sd = 2,
r <- c(0, .7, 0, 0, .7, 0),
plot = FALSE)
design_result
power_result <- ANOVA_power(ANOVA_design, alpha_level = .05, nsims, 1000)
power_result <- ANOVA_power(ANOVA_design, alpha_level = .05, p.adjust = NULL, nsims, 1000)
?p.adjus
?p.adjust
power_result <- ANOVA_power(ANOVA_design, alpha_level = .05, nsims = 1000, p.adjust = "none")
power_result <- ANOVA_power(ANOVA_design, alpha = .05, nsims = 100)
?ANOVA_power
power_result <- ANOVA_power(ANOVA_design, p_adjust = "none", alpha = .05, nsims = 100)
power_result <- ANOVA_power(ANOVA_design, p_adjust = "none", alpha_level = .05, nsims = 100)
power_result <- ANOVA_power(ANOVA_design, alpha_level = .05, nsims = 1000, p_adjust = "none")
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 1000, p_adjust = "none")
design_result
design_result <- ANOVA_design(design = "2w*2b",
n = 104,
mu = c(0, 0, 0, 1),
sd = 2,
r <- c(.7,0, 0, 0, 0, .7),
plot = FALSE)
design_result
?design_result
?ANOVA_design
design_result <- ANOVA_design(design = "2w*2b",
n = 104,
mu = c(0, 0, 0, 1),
sd = 2,
r <- .7,
plot = FALSE)
design_result
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, 1),
sd = 2,
r <- .7,
plot = FALSE)
design_result
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .1),
sd = 2,
r <- .7,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .4),
sd = 2,
r <- .7,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .2),
sd = 1,
r <- .7,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .2),
sd = 1,
r <- .5,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .2),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .2),
sd = 1,
r <- .7,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .5),
sd = 1,
r <- .7,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .2),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*4w",
n = 104,
mu = c(0, 0, 0, .2, 0, .2, 0, .2),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result
design_result <- ANOVA_design(design = "2b*4w",
n = 104,
mu = c(0, .2, .2, .2, 0, .2, .2, .2),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, .05, 0, .25),
sd = 1,
r <- .7,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, .05, 0, .25),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .25),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .3),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .26),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 100, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .26),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 1000, p_adjust = "none")
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, .25),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 1000, p_adjust = "none")
power_result$pc_results
power_result$main_results
power_result$main_results[3.1]
power_result$main_results[3,1]
ES <- seq(0, 1, by = .05)
pow <- rep(NA, length(ES))
for (e in 1:length(ES)){
design_result <- ANOVA_design(design = "2b*2w",
n = 104,
mu = c(0, 0, 0, ES[e]),
sd = 1,
r <- .8,
plot = FALSE)
power_result <- ANOVA_power(design_result, alpha_level = .05, nsims = 1000, p_adjust = "none")
pow[e] <- power_result$main_results[3,1]
}
cbind(ES, pow)
pow.100 <- pow / 100
plot (ES, pow.100, type = "l", col = "red", xlab = "Cohen's d", ylab = "Power")
points(ES, pow.100, pch = 20, col = "red")
pow.100 <- pow / 100
plot (ES, pow.100, pch = 20, col = "red", xlab = "Cohen's d", ylab = "Power", main = "Empirical Power Over 1000 Replications")
abline(h = .8, col = "black")
lines(ES, pow.100, col = "red")
pow.100 <- pow / 100
plot (ES, pow.100, pch = 20, col = "red", xlab = "Cohen's d", ylab = "Power", main = "Power to detect interaction between treatment and time at N = 104")
abline(h = .8, col = "black")
lines(ES, pow.100, col = "red")
pow.100 <- pow / 100
plot (ES, pow.100, pch = 20, cex = 1.5, col = "red", xlab = "Cohen's d", ylab = "Power", main = "Power to detect interaction between treatment and time at N = 104")
abline(h = .8, col = "black")
lines(ES, pow.100, col = "red", lwd = 1.5)
library(devtools)
setwd("C:/Users/colev/Dropbox/aMNLFA_12212017/UMNfix_082021")
setwd("C:/Users/colev/Dropbox/aMNLFA_12212017/UMNfix_082021/aMNLFA")
devtools::build()
.onAttach <- function() {
packageStartupMessage(
'Version:  1.1.0 \n',
'aMNLFA is a collaborative project which aims to help researchers implement moderated nonlinear factor analysis (MNLFA) through a series of automated steps, outlined by Gottfredson et al. (2019). \n\n Please note: This package generates TEMPLATES for Mplus inputs, which can and should be inspected, altered, and run by the user. In addition to being presented without warranty of every kind, the package is provided under the assumption that everyone who uses it is reading, interpreting, understanding, and altering every Mplus input and output file.\n\n There is no one right way to implement MNLFA, and this package exists solely to save users time as they generate Mplus syntax according to their own judgment.',
paste("Hallquist, M. N. & Wiley, J. F. (2018).",
"MplusAutomation: An R Package for Facilitating Large-Scale Latent Variable Analyses in Mplus.",
"Structural Equation Modeling, 25, 621-638.",
"doi: 10.1080/10705511.2017.1402334.\n\n")
)
}
.onAttach
# display disclaimer about MNLFA model generation
.onAttach <- function() {
packageStartupMessage(
'Version:  1.1.0 \n',
'aMNLFA is a collaborative project which aims to help researchers implement moderated nonlinear factor analysis (MNLFA) through a series of automated steps, outlined by Gottfredson et al. (2019). \n\n Please note: This package generates TEMPLATES for Mplus inputs, which can and should be inspected, altered, and run by the user. In addition to being presented without warranty of every kind, the package is provided under the assumption that everyone who uses it is reading, interpreting, understanding, and altering every Mplus input and output file.\n\n There is no one right way to implement MNLFA, and this package exists solely to save users time as they generate Mplus syntax according to their own judgment.',
)
}
.onAttach()
.onAttach
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
.onAttach <- function(libname, pkgname) {
desc  <- packageDescription(pkgname, libname)
packageStartupMessage(
'Version:  ', desc$Version, '\n',
'aMNLFA is a collaborative project which aims to help researchers implement moderated nonlinear factor analysis (MNLFA) through a series of automated steps, outlined by Gottfredson et al. (2019). \n',
'Please note: This package generates TEMPLATES for Mplus inputs, which can and should be inspected, altered, and run by the user. In addition to being presented without warranty of any kind, the package is provided under the assumption that everyone who uses it is reading, interpreting, understanding, and altering every Mplus input and output file. \n',
'There is no one right way to implement MNLFA, and this package exists solely to save users time as they generate Mplus syntax according to their own judgment.',
)
}
.onAttach
devtools::build()
devtools::document()
